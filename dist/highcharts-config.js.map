{"version":3,"sources":["webpack://buildConfig/webpack/universalModuleDefinition","webpack://buildConfig/webpack/bootstrap","webpack://buildConfig/./node_modules/pathington/es/constants.js","webpack://buildConfig/./node_modules/pathington/es/index.js","webpack://buildConfig/./node_modules/pathington/es/utils.js","webpack://buildConfig/./src/classes/ChartConfig.js","webpack://buildConfig/./src/classes/Config.js","webpack://buildConfig/./src/classes/OptionsConfig.js","webpack://buildConfig/./src/constants.js","webpack://buildConfig/./src/index.js","webpack://buildConfig/./src/utils.js","webpack://buildConfig/external \"unchanged\""],"names":["isArray","Array","ChartConfig","addType","type","seriesPassed","TypeError","series","config","options","getType","types","get","length","removeType","chartPath","remove","currentSeries","chart","indexString","filter","set","chartIndices","indexNumber","indexToRemove","updateType","seriesInstance","indexToUpdate","key","existingSeries","mergedSeries","Config","CHART_CONVENIENCE_METHOD_NAMES","forEach","addMethod","isValid","validate","Constructor","methodName","method","methodToAssign","Object","defineProperty","prototype","configurable","enumerable","value","writable","clear","constructor","path","merge","otherConfigs","reduce","newConfig","paths","keys","toString","JSON","stringify","OptionsConfig","OPTIONS_CONVENIENCE_METHOD_NAMES","CHARTS_UNABLE_TO_BE_MIXED","buildConfig","addChartMethod","addOptionsMethod","getOwnPropertySymbols","hasOwnProperty","isFunction","object","isNAN","isPlainObject","isUndefined","assignFallback","target","sources","assigned","source","call","symbols","assignedWithSymbols","symbol","assign","createAddMethod","createAddMethodWrapper","result","createBuildConfig","getArrayOfItem","item","getPathArray","getConfig","getDefaultSeries","getNamespacedKey","namespace","canCombineChartTypes","every","indexOf","createPropertyConvenienceMethod","property","subKey","arguments","cleanArgs","updatedObject","keyWithoutProperty","isMixedChartType","originalType","slice","some","getFirstIfOnly","items","getMatchingChartIndices","indices","seriesIndex","push","getNewChartSeries","map","getNewConfigFromObject","currentConfig","getNewConfigWithSeries","updatedSeries","concat","getSpecificSeries","indexOfChart","matches","match","specificSeries","matchingSeries","seriesType","removeOrOmit"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,cAAc,OAAO;AACrB;AACA,cAAc,SAAS;AACvB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACO;AACP;AACA;AACA;AACA,GAAG;AACH,aAAa;AACb;AACA;AACA;AACA,cAAc,OAAO;AACrB;;AAEO;AACP;AACA,cAAc,OAAO;AACrB;;AAEO;AACP;AACA,cAAc,OAAO;AACrB;;AAEO;AACP;AACA,cAAc,OAAO;AACrB;;AAEO;AACP;AACA,cAAc,cAAc;AAC5B;;AAEO,2BAA2B,EAAE;AACpC;AACA,cAAc,OAAO;AACrB;;AAEO;AACP;AACA,cAAc,OAAO;AACrB;;AAEO,uB;;;;;;;;;;;;ACjDP;AAAA;AAAA;AAAA;AAAA;AAAA;AAC2C;;AAEoD;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,OAAO,uDAAY;AACnB;AACA;;AAEA,+BAA+B,2EAA4B;AAC3D;AA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","file":"highcharts-config.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"unchanged\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"buildConfig\", [\"unchanged\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"buildConfig\"] = factory(require(\"unchanged\"));\n\telse\n\t\troot[\"buildConfig\"] = factory(root[\"unchanged\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_unchanged__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * @constant {Object} CACHE\n *\n * @property {function} clear clear the cache results\n * @property {Object} results the map of path => array results\n * @property {number} size the size of the cache\n */\nexport var CACHE = {\n  clear: function clear() {\n    CACHE.results = {};\n    CACHE.size = 0;\n  },\n  results: {},\n  size: 0\n};\n/**\n * @constant {RegExp} DOTTY_WITH_BRACKETS_SYNTAX\n */\n\nexport var DOTTY_WITH_BRACKETS_SYNTAX = /\"[^\"]+\"|`[^`]+`|'[^']+'|[^.[\\]]+/g;\n/**\n * @constant {number} MAX_CACHE_SIZE\n */\n\nexport var MAX_CACHE_SIZE = 500;\n/**\n * @constant {RegExp} NUMBER\n */\n\nexport var NUMBER = /^\\d+$/i;\n/**\n * @constant {RegExp} QUOTED_KEY\n */\n\nexport var QUOTED_KEY = /^\"[^\"]+\"|`[^`]+`|'[^']+'$/;\n/**\n * @constant {Array<string>} VALID_QUOTES\n */\n\nexport var VALID_QUOTES = /^[\"'`]{1}$/;\n/**\n * @constant {RegExp} VALID_KEY\n */\n\nexport var VALID_KEY = /^\\d+$|^[a-zA-Z_$][\\w$]+$/;\n/**\n * @constant {RegExp} WHITE_SPACE\n */\n\nexport var WHITE_SPACE = /\\s/;","// constants\nimport { VALID_QUOTES } from './constants'; // utils\n\nimport { createGetNormalizedCreateKey, getNormalizedParseKey, parseStringPath } from './utils';\n/**\n * @function create\n *\n * @description\n * create a new path string based on the path and quote passed\n *\n * @param {Array<number|string>} path the path to convert to a string\n * @param {string} [quote=\"] the quote string to use when quoting keys\n * @returns {string} the path string\n */\n\nexport var create = function create(path, quote) {\n  if (quote === void 0) {\n    quote = '\"';\n  }\n\n  if (!Array.isArray(path)) {\n    throw new ReferenceError('path passed must be an array');\n  }\n\n  if (!VALID_QUOTES.test(quote)) {\n    throw new SyntaxError(\"quote \" + quote + \" passed is invalid, must be \\\", `, or '.\");\n  }\n\n  var pathString = path.reduce(createGetNormalizedCreateKey(quote), '');\n  return pathString[0] === '.' ? pathString.slice(1) : pathString;\n};\n/**\n * @function parse\n *\n * @description\n * the path parsed into a valid array of keys / indices\n *\n * @param {Array<number|string>|number|string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parse = function parse(path) {\n  if (typeof path === 'string') {\n    return parseStringPath(path);\n  }\n\n  if (Array.isArray(path)) {\n    return path.map(getNormalizedParseKey);\n  }\n\n  return [typeof path === 'number' ? path : \"\" + path];\n};","// constants\nimport { CACHE, DOTTY_WITH_BRACKETS_SYNTAX, MAX_CACHE_SIZE, NUMBER, QUOTED_KEY, VALID_KEY, WHITE_SPACE } from './constants';\n/**\n * @function isNumericKey\n *\n * @description\n * is the key passed a numeric string\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key passed a numeric string\n */\n\nexport var isNumericKey = function isNumericKey(key) {\n  return !!key.length && NUMBER.test(key);\n};\n/**\n * @function isQuotedKey\n *\n * @description\n * is the key passed a quoted key\n *\n * @param {string} key the key to test\n * @returns {boolean} is the key a quoted key\n */\n\nexport var isQuotedKey = function isQuotedKey(key) {\n  return QUOTED_KEY.test(key);\n};\n/**\n * @function shouldBeInBrackets\n *\n * @description\n * should the key passed be encased in brackets when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in brackets\n */\n\nexport var shouldBeInBrackets = function shouldBeInBrackets(key) {\n  return typeof key === 'number' || isNumericKey(key) || isQuotedKey(key);\n};\n/**\n * @function shouldBeInQuotes\n *\n * @description\n * should the key passed be encased in quotes when in the path string\n *\n * @param {*} key the key that is being added to the path string\n * @returns {boolean} should the key be in quotes\n */\n\nexport var shouldBeInQuotes = function shouldBeInQuotes(key) {\n  return WHITE_SPACE.test(key) || !VALID_KEY.test(key);\n};\n/**\n * @function createGetNormalizedCreateKey\n *\n * @description\n * get the normalized path string based on the quote and key passed\n *\n * @param {string} [quote=\"] the quote string to use\n * @returns {function(string, *): string}\n */\n\nexport var createGetNormalizedCreateKey = function createGetNormalizedCreateKey(quote) {\n  return function (existingString, key) {\n    var normalizedKey = shouldBeInQuotes(key) ? \"\" + quote + key + quote : key;\n    return shouldBeInBrackets(normalizedKey) ? existingString + \"[\" + normalizedKey + \"]\" : existingString + \".\" + normalizedKey;\n  };\n};\n/**\n * @function getNormalizedParseKey\n *\n * @description\n * get the key as a number if parseable, or as a quoted string if applicable\n *\n * @param {string} key the key to try to parse\n * @returns {number|string} the parsed key\n */\n\nexport var getNormalizedParseKey = function getNormalizedParseKey(key) {\n  var cleanKey = isQuotedKey(key) ? key.substring(1, key.length - 1) : key;\n  return isNumericKey(cleanKey) ? +cleanKey : cleanKey;\n};\n/**\n * @function parsePath\n *\n * @description\n * parse the path, memoizing the results\n *\n * @param {string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\n\nexport var parseStringPath = function parseStringPath(path) {\n  if (CACHE.results[path]) {\n    return CACHE.results[path];\n  }\n\n  if (CACHE.size > MAX_CACHE_SIZE) {\n    CACHE.clear();\n  }\n\n  CACHE.results[path] = path ? path.match(DOTTY_WITH_BRACKETS_SYNTAX).map(getNormalizedParseKey) : [path];\n  CACHE.size++;\n  return CACHE.results[path];\n};","// classes\nimport Config from './Config';\n\n// constants\nimport {CHART_CONVENIENCE_METHOD_NAMES} from '../constants';\n\n// utils\nimport {\n  assign,\n  getArrayOfItem,\n  getFirstIfOnly,\n  getMatchingChartIndices,\n  getNewChartSeries,\n  getNewConfigWithSeries,\n  getPathArray,\n  getSpecificSeries,\n  isNAN,\n  isPlainObject,\n  isUndefined,\n} from '../utils';\n\n/**\n * @module classes/ChartConfig\n */\n\nconst {isArray} = Array;\n\n/**\n * @private\n *\n * @class ChartConfig\n * @classdesc configuration object builder for charts\n */\nclass ChartConfig extends Config {\n  /**\n   * @function addType\n   *\n   * @description\n   * add a chart type with provided series\n   *\n   * @param {string} type chart type to add to config\n   * @param {Array<Object>} seriesPassed data series to populate chart with\n   * @returns {ChartConfig} new config class\n   */\n  addType(type, seriesPassed) {\n    if (!isArray(seriesPassed) && !isPlainObject(seriesPassed)) {\n      throw new TypeError('Series passed must be either a plain object or an array of plain objects.');\n    }\n\n    const series = isArray(seriesPassed) ? seriesPassed : [seriesPassed];\n    const config = getNewConfigWithSeries(this.config, getNewChartSeries(series, type));\n\n    return new ChartConfig(config, this.options);\n  }\n\n  /**\n   * @function getType\n   *\n   * @description\n   * get a specific type (or a list of types) from the series in the config\n   *\n   * @param {Array<string>|string} types the type(s) to select from the config\n   * @returns {Array<Object>|Object|null} the matching type(s)\n   */\n  getType(types) {\n    const series = this.get('series');\n    const length = series ? series.length : 0;\n\n    if (!length) {\n      return null;\n    }\n\n    return isUndefined(types) ? getFirstIfOnly(series) : getSpecificSeries(series, getArrayOfItem(types));\n  }\n\n  /**\n   * @function removeType\n   *\n   * @description\n   * remove an instance of a chart type, all instances, or all charts\n   *\n   * @param {Array<number|string>|string} [chartPath] chart type with optional index\n   * @returns {ChartConfig} new config class\n   */\n  removeType(chartPath) {\n    if (isUndefined(chartPath)) {\n      return this.remove('series');\n    }\n\n    const {series: currentSeries = []} = this.config;\n\n    if (!currentSeries.length) {\n      return this;\n    }\n\n    const [chart, indexString] = getPathArray(chartPath);\n\n    if (isUndefined(indexString)) {\n      const series = currentSeries.filter(({type}) => type !== chart);\n\n      return this.set('series', series);\n    }\n\n    const chartIndices = getMatchingChartIndices(currentSeries, chart);\n    const indexNumber = +indexString;\n    const indexToRemove = chartIndices[isNAN(indexNumber) ? 0 : indexNumber];\n\n    return isUndefined(indexToRemove) ? this : this.remove(`series[${indexToRemove}]`);\n  }\n\n  /**\n   * @function updateType\n   *\n   * @description\n   * update an existing type in the series of the config\n   *\n   * @param {Array<number|string>|string} chartPath chart type with optional index\n   * @param {Object} seriesInstance value to update matching series instance to\n   * @returns {ChartConfig} new config class\n   */\n  updateType(chartPath, seriesInstance) {\n    const {series: currentSeries = []} = this.config;\n\n    const length = currentSeries.length;\n\n    if (isUndefined(chartPath) || !length) {\n      return this;\n    }\n\n    if (!isPlainObject(seriesInstance)) {\n      throw new TypeError('Series passed must be a plain object.');\n    }\n\n    const [chart, indexString] = getPathArray(chartPath);\n\n    const chartIndices = getMatchingChartIndices(currentSeries, chart);\n    const indexNumber = +indexString;\n    const indexToUpdate = chartIndices[isNAN(indexNumber) ? 0 : indexNumber];\n\n    const key = `series[${indexToUpdate}]`;\n    const existingSeries = this.get(key);\n\n    if (isUndefined(existingSeries)) {\n      return this;\n    }\n\n    const mergedSeries = assign({}, existingSeries, seriesInstance);\n    const series = getNewChartSeries([mergedSeries], chart);\n\n    return isUndefined(indexToUpdate) ? this : this.set(key, series[0]);\n  }\n}\n\nCHART_CONVENIENCE_METHOD_NAMES.forEach(ChartConfig.addMethod(ChartConfig));\n\nexport default ChartConfig;\n","// external dependencies\nimport {\n  get,\n  merge,\n  set,\n} from 'unchanged';\n\n// utils\nimport {\n  assign,\n  createAddMethodWrapper,\n  createPropertyConvenienceMethod,\n  getArrayOfItem,\n  getConfig,\n  getNewConfigFromObject,\n  isFunction,\n  isPlainObject,\n  isUndefined,\n  removeOrOmit,\n} from '../utils';\n\n/**\n * @module classes/Config\n */\n\n/**\n * @private\n *\n * @class Config\n * @classdesc configuration object builder base class\n */\nclass Config {\n  /**\n   * @function constructor\n   *\n   * @description\n   * build the initial state of the config class\n   *\n   * @param {Object} [config={}] configuration to assign to the class\n   * @param {Object} [options={}] additional options for instantiating the class\n   * @returns {Config} configuration class\n   */\n  constructor(config = {}, options = {}) {\n    this.config = getConfig(Config, config);\n    this.options = assign({}, options);\n\n    const {validate} = this.options;\n\n    if (isFunction(validate)) {\n      this.isValid = validate(this.config);\n    }\n\n    return this;\n  }\n\n  /**\n   * @instance\n   * @type {Object|null}\n   */\n  config = null;\n\n  /**\n   * @instance\n   * @type {boolean|null}\n   */\n  isValid = null;\n\n  /**\n   * @instance\n   * @type {Object|null}\n   */\n  options = null;\n\n  /**\n   * @function addConvenienceMethod\n   * @static\n   *\n   * @description\n   * add a convenience method to the constructor passed\n   *\n   * @param {function} Constructor constructor to assign method to prototype of\n   * @param {Object} Constructor.prototype prototype to assign method to\n   * @returns {function(string, (function|number)): (ChartConfig|OptionsConfig)} method to add convenience method\n   */\n  static addMethod(Constructor) {\n    return (methodName, method) => {\n      const methodToAssign = isFunction(method)\n        ? createAddMethodWrapper(Constructor, method)\n        : createPropertyConvenienceMethod(methodName);\n\n      Object.defineProperty(Constructor.prototype, methodName, {\n        configurable: false,\n        enumerable: false,\n        value: methodToAssign,\n        writable: true,\n      });\n\n      return Constructor;\n    };\n  }\n\n  /**\n   * @function clear\n   *\n   * @description\n   * clear out the current config and start anew\n   *\n   * @returns {Config} new config class\n   */\n  clear() {\n    return new this.constructor({}, this.options);\n  }\n\n  /**\n   * @function get\n   *\n   * @description\n   * get a value from a path (top-level or nested) from the config\n   *\n   * @param {string} path path to retrieve from config\n   * @returns {*} value at path\n   */\n  get(path) {\n    return isUndefined(path) ? this.config : get(path, this.config);\n  }\n\n  /**\n   * @function merge\n   *\n   * @description\n   * merge the configs passed to form a new config\n   *\n   * @returns {Config} new config class\n   */\n  merge(...otherConfigs) {\n    if (!otherConfigs.length) {\n      return this;\n    }\n\n    const config = otherConfigs.reduce(\n      (newConfig, config) => merge(null, newConfig, getConfig(Config, config)),\n      this.config\n    );\n\n    return new this.constructor(config, this.options);\n  }\n\n  /**\n   * @function remove\n   *\n   * @description\n   * remove item at path (top-level or nested) in the config\n   *\n   * @param {string} paths path to remove from config\n   * @returns {Config} new config class\n   */\n  remove(paths) {\n    const keys = getArrayOfItem(paths);\n    const config = removeOrOmit(keys, this.config);\n\n    return new this.constructor(config, this.options);\n  }\n\n  /**\n   * @function set\n   *\n   * @param {string} path path to set in config\n   * @param {*} value value to assign to path\n   * @returns {Config} new config class\n   */\n  set(path, value) {\n    if (isUndefined(path)) {\n      return this;\n    }\n\n    const config = isPlainObject(path) ? getNewConfigFromObject(this.config, path) : set(path, value, this.config);\n\n    return new this.constructor(config, this.options);\n  }\n\n  /**\n   * @function toString\n   *\n   * @description\n   * return stringified config\n   *\n   * @returns {string} stringified config\n   */\n  toString() {\n    return JSON.stringify(this.config, null, 2);\n  }\n}\n\nexport default Config;\n","// classes\nimport Config from './Config';\n\n// constants\nimport {OPTIONS_CONVENIENCE_METHOD_NAMES} from '../constants';\n\n/**\n * @module classes/OptionsConfig\n */\n\n/**\n * @private\n *\n * @class OptionsConfig\n * @classdesc configuration object builder for global options\n */\nclass OptionsConfig extends Config {}\n\nOPTIONS_CONVENIENCE_METHOD_NAMES.forEach(OptionsConfig.addMethod(OptionsConfig));\n\nexport default OptionsConfig;\n","/**\n * @module constants\n */\n\n/**\n * @private\n *\n * @constant\n * @type {Array<string>}\n * @desfault\n */\nexport const CHART_CONVENIENCE_METHOD_NAMES = [\n  'accessibility',\n  'chart',\n  'colorAxis',\n  'colors',\n  'credits',\n  'data',\n  'defs',\n  'drilldown',\n  'exporting',\n  'labels',\n  'legend',\n  'loading',\n  'mapNavigation',\n  'navigation',\n  'noData',\n  'pane',\n  'plotOptions',\n  'responsive',\n  'series',\n  'subtitle',\n  'title',\n  'tooltip',\n  'xAxis',\n  'yAxis',\n  'zAxis',\n];\n\n/**\n * @private\n *\n * @constant\n * @type {Array<string>}\n * @default\n */\nexport const OPTIONS_CONVENIENCE_METHOD_NAMES = ['global', 'lang'];\n\n/**\n * @private\n *\n * @constant\n * @type {Array<string>}\n * @default\n */\nexport const CHARTS_UNABLE_TO_BE_MIXED = ['funnel', 'gauge', 'heatmap', 'pyramid', 'solidgauge', 'treemap'];\n","// classes\nimport ChartConfig from './classes/ChartConfig';\nimport OptionsConfig from './classes/OptionsConfig';\n\n// utils\nimport {\n  createAddMethod,\n  createBuildConfig,\n} from './utils';\n\n/**\n * @module buildConfig\n */\n\n/**\n * @function buildConfig\n *\n * @description\n * create a configuration builder class\n *\n * @example\n * import buildConfig from 'highcharts-config';\n *\n * const config = buildConfig()\n *   .addType('line', {\n *     data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6],\n *     name: 'Stuff'\n *   })\n *   .get();\n *\n * console.log(config);\n * // {series: [{data: [...], name: 'Stuff', type: 'line'}]}\n *\n * @param {Object} [config={}] configuration to assign\n * @param {Object} [options={}] additional options for the configuration class\n * @returns {ChartConfig} the configuration class for a given chart\n */\nconst buildConfig = createBuildConfig(ChartConfig);\n\n/**\n * @function buildConfig.addChartMethod\n *\n * @description\n * add a custom method to the chart config builder\n *\n * @param {string} methodName name of the custom method\n * @param {function} method method to execute in the chain\n * @returns {function} constructor to add method to\n */\nbuildConfig.addChartMethod = createAddMethod(ChartConfig, buildConfig);\n\n/**\n * @function buildConfig.addOptionsMethod\n *\n * @description\n * add a custom method to the options config builder\n *\n * @param {string} methodName name of the custom method\n * @param {function} method method to execute in the chain\n * @returns {function} constructor to add method to\n */\nbuildConfig.addOptionsMethod = createAddMethod(OptionsConfig, buildConfig);\n\n/**\n * @function buildConfig.chart\n *\n * @description\n * create a configuration builder class for charts\n *\n * @example\n * import buildConfig from 'highcharts-config';\n *\n * const config = buildConfig()\n *   .addType('line', {\n *     data: [7.0, 6.9, 9.5, 14.5, 18.2, 21.5, 25.2, 26.5, 23.3, 18.3, 13.9, 9.6],\n *     name: 'Stuff'\n *   })\n *   .get();\n *\n * console.log(config);\n * // {series: [{data: [...], name: 'Stuff', type: 'line'}]}\n *\n * @param {Object} [config={}] configuration to assign\n * @param {Object} [options={}] additional options for the configuration class\n * @returns {ChartConfig} the configuration class for a given chart\n */\nbuildConfig.chart = createBuildConfig(ChartConfig);\n\n/**\n * @function buildConfig.options\n *\n * @description\n * create a configuration builder class for options\n *\n * @param {Object} [config={}] configuration to assign\n * @param {Object} [options={}] additional options for the configuration class\n * @returns {OptionsConfig} the configuration class for options\n */\nbuildConfig.options = createBuildConfig(OptionsConfig);\n\nexport default buildConfig;\n","// external dependencies\nimport {parse} from 'pathington';\nimport {\n  getOr,\n  remove,\n  set,\n} from 'unchanged';\n\n// constants\nimport {CHARTS_UNABLE_TO_BE_MIXED} from './constants';\n\nconst {isArray} = Array;\nconst {getOwnPropertySymbols, keys} = Object;\nconst {hasOwnProperty} = Object.prototype;\n\n/**\n * @private\n *\n * @function isFunction\n *\n * @description\n * is the object passed a function\n *\n * @param {*} object the object to test\n * @returns {boolean} is the object a function\n */\nexport const isFunction = (object) => typeof object === 'function';\n\n/**\n * @private\n *\n * @function isNAN\n *\n * @description\n * is the object passed a NaN\n *\n * @param {*} object the object to test\n * @returns {boolean} is the object a NaN\n */\nexport const isNAN = (object) => object !== object;\n\n/**\n * @private\n *\n * @function isPlainObject\n *\n * @description\n * is the object passed a plain object\n *\n * @param {*} object the object to test\n * @returns {boolean} is the object a plain object\n */\nexport const isPlainObject = (object) => !!object && object.constructor === Object;\n\n/**\n * @private\n *\n * @function isUndefined\n *\n * @description\n * is the object passed undefined\n *\n * @param {*} object the object to test\n * @returns {boolean} is the object undefined\n */\nexport const isUndefined = (object) => object === void 0;\n\n/**\n * @function assignFallback\n *\n * @description\n * the fallback for when Object.assign() is unavailable\n *\n * @param {Object} target the target to assign to\n * @param  {...Object} sources the sources to assign to the target\n * @returns {Object} the assigned object\n */\nexport const assignFallback = (target, ...sources) =>\n  sources.reduce((assigned, source) => {\n    if (!isPlainObject(source) && !isUndefined(source)) {\n      return assigned;\n    }\n\n    for (let key in source) {\n      if (hasOwnProperty.call(source, key)) {\n        assigned[key] = source[key];\n      }\n    }\n\n    if (typeof getOwnPropertySymbols !== 'function') {\n      return assigned;\n    }\n\n    const symbols = getOwnPropertySymbols(source);\n\n    return symbols.reduce((assignedWithSymbols, symbol) => {\n      assignedWithSymbols[symbol] = source[symbol];\n\n      return assignedWithSymbols;\n    }, assigned);\n  }, target);\n\nexport const assign = typeof Object.assign === 'function' ? Object.assign : assignFallback;\n\n/**\n * @module utils\n */\n\n/**\n * @private\n *\n * @function createAddMethod\n *\n * @description\n * create an add method function for specific constructor\n *\n * @param {function} Constructor constructor to assign method to\n * @param {function} Constructor.addMethod static method to add method to Constructor\n * @param {function} buildConfig main function, returned to allow chainability\n * @returns {function(string, function): function} add method to Constructor\n */\nexport const createAddMethod = (Constructor, buildConfig) => (methodName, method) => {\n  if (typeof method === 'function') {\n    Constructor.addMethod(Constructor)(methodName, method);\n\n    return buildConfig;\n  }\n\n  throw new TypeError('The second parameter needs to be a function.');\n};\n\n/**\n * @private\n *\n * @function createAddMethodWrapper\n *\n * @description\n * create wrapper for method to ensure chainability\n *\n * @param {function} Constructor constructor to assign method to\n * @param {function} method method to execute in chain\n * @returns {function(): (ChartConfig|OptionsConfig)} new configuration class\n */\nexport const createAddMethodWrapper = function(Constructor, method) {\n  return function() {\n    const result = method.call(this, this.config, this);\n    const config = isPlainObject(result) ? result : this.config;\n\n    return new Constructor(config, this.options);\n  };\n};\n\n/**\n * @private\n *\n * @function createBuildConfig\n *\n * @description\n * create a buildConfig function specific to a constructor\n *\n * @param {function} Constructor constructor to call with config and options\n * @returns {function(Object, Object): (ChartConfig|OptionsConfig)}\n */\nexport const createBuildConfig = (Constructor) => (config = {}, options = {}) => new Constructor(config, options);\n\n/**\n * @private\n *\n * @function getArrayOfItem\n *\n * @description\n * get the array form of the item passed, if not already an array\n *\n * @param {*} item item to return in array form\n * @returns {Array<*>} array form of item\n */\nexport const getArrayOfItem = (item) => (isArray(item) ? item : [item]);\n\n/**\n * @private\n *\n * @function getPathArray\n *\n * @description\n * get the array form of the full path passed\n *\n * @param {Array<number|string>|string} path path to get array form of\n * @returns {Array<number|string>} array form of path\n */\nexport const getPathArray = (path) => (isArray(path) ? path : parse(path));\n\n/**\n * @private\n *\n * @function getConfig\n *\n * @description\n * curried function to get the config object based on if it is a Config or not\n *\n * @param {function} Config base config class\n * @param {Config|Object} config the object to test\n * @returns {Object} the config object\n */\nexport const getConfig = (Config, config) => (config instanceof Config ? config.get() : config);\n\n/**\n * @private\n *\n * @function getDefaultSeries\n *\n * @description\n * get the series in the config or an empty array\n *\n * @param {Object} config config to retrieve series from\n * @returns {Array<Object>} series for the given config\n */\nexport const getDefaultSeries = (config) => getOr([], ['series'], config);\n\n/**\n * @private\n *\n * @function getKeyWithProperty\n *\n * @description\n * get the key namespaced\n *\n * @param {string} key key to namespace\n * @param {string} namespace namespace of key\n * @returns {string} complete key\n */\nexport const getNamespacedKey = (key, namespace) => `${namespace}.${key}`;\n\n/**\n * @private\n *\n * @function canCombineChartTypes\n *\n * @description\n * does the chart types in series allow for combination with other chart types\n *\n * @param {Array<Object>} series series data sets\n * @returns {boolean} does the series allow for combination of all the charts added\n */\nexport const canCombineChartTypes = (series) => series.every(({type}) => !~CHARTS_UNABLE_TO_BE_MIXED.indexOf(type));\n\n/**\n * @private\n *\n * @function createPropertyConvenienceMethod\n *\n * @description\n * create a convenience property for the class\n *\n * @param {string} property property name\n * @returns {Function} method to assign to class at property\n */\nexport const createPropertyConvenienceMethod = (property) =>\n  function(subKey, value) {\n    const length = arguments.length;\n\n    if (!length) {\n      return this.get(property);\n    }\n\n    if (isPlainObject(subKey)) {\n      const cleanArgs = keys(subKey).reduce((updatedObject, keyWithoutProperty) => {\n        updatedObject[getNamespacedKey(keyWithoutProperty, property)] = subKey[keyWithoutProperty];\n\n        return updatedObject;\n      }, {});\n\n      return this.set(cleanArgs);\n    }\n\n    if (isArray(subKey)) {\n      return this.set(property, subKey);\n    }\n\n    const key = getNamespacedKey(subKey, property);\n\n    return length === 1 ? this.get(key) : this.set(key, value);\n  };\n\n/**\n * @private\n *\n * @function isMixedChartType\n *\n * @description\n * is the series a mixture of chart types or a single type\n *\n * @param {Array<Object>} series series data sets\n * @returns {boolean} are multiple chart types present\n */\nexport const isMixedChartType = (series) => {\n  if (!series.length) {\n    return false;\n  }\n\n  const originalType = series[0].type;\n\n  return series.slice(1).some(({type}) => type !== originalType);\n};\n\nexport const getFirstIfOnly = (items) => (items.length === 1 ? items[0] : items);\n\n/**\n * @private\n *\n * @function getMatchingChartIndices\n *\n * @description\n * get the indices of the series where the type is the same as the chart passed\n *\n * @param {Array<Object>} series the series to get the indices from\n * @param {string} chart the chart to match indices of\n * @returns {Array<T>}\n */\nexport const getMatchingChartIndices = (series, chart) =>\n  series.reduce((indices, {type}, seriesIndex) => {\n    if (type === chart) {\n      indices.push(seriesIndex);\n    }\n\n    return indices;\n  }, []);\n\n/**\n * @private\n *\n * @function getNewChartSeries\n *\n * @description\n * return the new series sets augmented with the chart type\n *\n * @param {Array<Object>} series series data sets\n * @param {string} type the type of chart\n * @returns {Array<Object>} series augmented with chart type\n */\nexport const getNewChartSeries = (series, type) =>\n  series.map((seriesInstance) => (seriesInstance.type ? seriesInstance : assign({}, seriesInstance, {type})));\n\n/**\n * @private\n *\n * @function getNewConfigFromObject\n *\n * @description\n * get a new configuration object based on iteratively setting new values at each key\n *\n * @param {Object} currentConfig configuration of the given instance\n * @param {Object} object key => value pairs to assign to the config\n * @returns {Object} new configuration object\n */\nexport const getNewConfigFromObject = (currentConfig, object) =>\n  keys(object).reduce((config, key) => set(key, object[key], config), currentConfig);\n\n/**\n * @private\n *\n * @function getNewConfigWithSeries\n *\n * @description\n * get a new configuration with an series concatenated with existing series\n *\n * @param {Object} config current configuration of the given instance\n * @param {Array<Object>} series series data sets\n * @returns {Object} new configuration object\n */\nexport const getNewConfigWithSeries = (config, series) => {\n  const updatedSeries = getDefaultSeries(config).concat(series);\n\n  if (isMixedChartType(updatedSeries) && !canCombineChartTypes(updatedSeries)) {\n    throw new TypeError('Cannot combine these chart types.');\n  }\n\n  return set(['series'], updatedSeries, config);\n};\n\n/**\n * @private\n *\n * @function getSpecificSeries\n *\n * @description\n * get series that match the provided types\n *\n * @param {Array<Object>} series series to find matches for\n * @param {Array<string> }types types of series to filter by\n * @returns {Array<Object>|Object} matching series\n */\nexport const getSpecificSeries = (series, types) => {\n  let chart, indexOfChart, matches, match;\n\n  const specificSeries = types.reduce((matchingSeries, type) => {\n    [chart, indexOfChart] = getPathArray(type);\n\n    matches = series.filter(({type: seriesType}) => seriesType === chart);\n\n    if (isUndefined(indexOfChart)) {\n      return matchingSeries.concat(matches);\n    }\n\n    match = matches[+indexOfChart];\n\n    if (!isUndefined(match)) {\n      matchingSeries.push(match);\n    }\n\n    return matchingSeries;\n  }, []);\n\n  return getFirstIfOnly(specificSeries);\n};\n\n/**\n * @private\n *\n * @function removeOrOmit\n *\n * @description\n * remove deeply-nested item from object based on whether it is an array or object\n *\n * @param {Array<string>} paths list of paths to remove\n * @param {Object} object object to remove values at paths from\n * @returns {Object} object with values at paths removed\n */\nexport const removeOrOmit = (paths, object) =>\n  paths.reduce((updatedObject, path) => remove(path, updatedObject), object);\n","module.exports = __WEBPACK_EXTERNAL_MODULE_unchanged__;"],"sourceRoot":""}